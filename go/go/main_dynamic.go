package main

/*
#cgo LDFLAGS: -L./c/lib -llancedb_go
#include "../c/lancedb.h"
#include <stdlib.h>
*/
import "C"

import (
	"fmt"
	"log"
	"os"
	"unsafe"

	"github.com/apache/arrow/go/v14/arrow"
	"github.com/apache/arrow/go/v14/arrow/array"
	"github.com/apache/arrow/go/v14/arrow/ipc"
	"github.com/apache/arrow/go/v14/arrow/memory"
)

func main() {
	buildArrowFile()
    // Read the Arrow IPC file generated by JavaScript
    buffer, err := os.ReadFile("./output.arrow")
    if err != nil {
        fmt.Println("Failed to read IPC file:", err)
        return
    }

    // Prepare C parameters for `create_table_c`
    bufPtr := (*C.uint8_t)(unsafe.Pointer(&buffer[0]))
    bufLen := C.size_t(len(buffer))

    // Assuming other parameters (like connection and table name) are set up
    // Define connection (assuming you have a create_connection function)
    uri := C.CString("./db") // replace with actual URI
    defer C.free(unsafe.Pointer(uri))

    // Call create_connection to establish a connection
    conn := C.create_connection(uri)
    if conn == nil {
        fmt.Println("Failed to create connection.")
        return
    }
    defer C.free_connection(conn)

    // Set up table name and mode
    tableName := C.CString("test_table")
    defer C.free(unsafe.Pointer(tableName))

    mode := C.CString("create")
    defer C.free(unsafe.Pointer(mode))

    // Call `create_table_c` with the IPC data
    table := C.create_table_c(conn, tableName, bufPtr, bufLen, mode)
    if table == nil {
        fmt.Println("Failed to create table.")
        return
    }
    defer C.free_table(table)
    searchVector := []float32{3.1, 4.1}
    vectorLen := C.size_t(len(searchVector))

    // Convert Go slice to C array
    vectorPtr := (*C.float)(unsafe.Pointer(&searchVector[0]))

    // Call the C function
    result := C.table_vector_search(table, vectorPtr, vectorLen)
    if result == nil {
        fmt.Println("Error: Vector search returned NULL")
        return
    }
    fmt.Println(*result)
      // Set a limit on the number of results
      C.set_limit(result, 10)

      maxBatchLength := C.uint(5)
      resultIterator := C.execute_query(result, maxBatchLength)
      if resultIterator == nil {
          // Retrieve and print the error message
         
          return
      }
      

    fmt.Println("Table created successfully!")
}


func buildArrowFile() {
    // Define a memory allocator
    mem := memory.NewGoAllocator()

    // Define the schema for the data, including a vector field
    fields := []arrow.Field{
        {Name: "id", Type: arrow.PrimitiveTypes.Int32},
        {Name: "name", Type: arrow.BinaryTypes.String},
        {Name: "vector", Type: arrow.FixedSizeListOf(2, arrow.PrimitiveTypes.Float32)},
    }
    schema := arrow.NewSchema(fields, nil)

    // Create builders for the columns
    idBuilder := array.NewInt32Builder(mem)
    nameBuilder := array.NewStringBuilder(mem)
    vectorBuilder := array.NewFixedSizeListBuilder(mem, 2, arrow.PrimitiveTypes.Float32)

    // Append data to the builders
    ids := []int32{1, 2, 3}
    names := []string{"Alice", "Bob", "Charlie"}
    vectors := [][]float32{{3.1, 4.1}, {5.9, 26.5}, {0.0, 1.2}}

    if len(ids) != len(names) || len(ids) != len(vectors) {
        log.Fatalf("row count mismatch between columns")
    }

    idBuilder.AppendValues(ids, nil)
    nameBuilder.AppendValues(names, nil)

    // Append vectors
    for _, vector := range vectors {
        vectorBuilder.Append(true) // append a new list entry
        float32Builder := vectorBuilder.ValueBuilder().(*array.Float32Builder)
        float32Builder.AppendValues(vector, nil)
    }

    // Convert builders to arrays
    idArray := idBuilder.NewArray()
    nameArray := nameBuilder.NewArray()
    vectorArray := vectorBuilder.NewArray()

    // Create an Arrow Record from the data
    record := array.NewRecord(schema, []arrow.Array{idArray, nameArray, vectorArray}, int64(idArray.Len()))

    // Open a file to write the IPC data
    file, err := os.Create("output.arrow")
    if err != nil {
        log.Fatalf("failed to create file: %v", err)
    }
    defer file.Close()

    // Use FileWriter for Arrow IPC file
    writer, err := ipc.NewFileWriter(file, ipc.WithSchema(schema))
    if err := writer.Write(record); err != nil {
        log.Fatalf("failed to write record: %v", err)
    }

    // Close the writer to ensure the footer is written
    if err := writer.Close(); err != nil {
        log.Fatalf("failed to close writer: %v", err)
    }

    // Clean up resources
    record.Release()
    idBuilder.Release()
    nameBuilder.Release()
    vectorBuilder.Release()
    idArray.Release()
    nameArray.Release()
    vectorArray.Release()

    log.Println("Arrow IPC file created successfully")
}
